= ECDSA Keep Signer Selection

Selecting the participants of ECDSA keeps
has some important differences to Random Beacon group selection.
Instead of a large signing group with a honest majority,
current threshold ECDSA implementations
limit the practical group size to 3-of-3.

For use in the Keep network,
two schemes appear viable candidates:
a non-interactive sortition with lazy evaluation of eligibility,
and an adapted version of the current Random Beacon ticket-based protocol.

== Requirements

As in the Random Beacon,
we have a number of basic requirements for the selection process:

Proportionality::
Each operator's chance of being selected
is proportional to the amount of KEEP tokens backing them.

Constant group size::
We want to select 3 members.
Not 4 members, nor 2 excepting that we then proceed to select a third member.
5 members is right out.

Efficiency::
We need to select members for every ECDSA keep,
as just reusing the same 3 every time would be bad^[citation needed]^.
This means we pay the price of member selection every time.
By the theorem of money is nice to have,
we would like to avoid
giving the miners money we could instead _keep_ to ourselves.

Manipulation resistance::
It's not good if we spend a whole load of money
implementing some kind of a fancypants hunger games of a selection process
only to find that some smartass operator circumvented the rules.
It's embarrassing if someone gets to be more clever than us on-chain,
so we need to be really clever to begin with.

In addition to the basic requirements from the Random Beacon,
such as the chances of getting selected
being proportional to the operator's stake,
ECDSA keeps have a number of more involved requirements
for a viable member selection process.

=== Fully backed bonding

In addition to the normal KEEP token stake,
ECDSA keeps must be able to utilize separate bonds as collateral.
Unlike staked KEEP which may become leveraged,
operations relying on these bonded tokens (initially ETH)
must always be fully backed.

Fully backed bonding makes eligibility determination more complex.
However, we only need to apply proportionality to the staked KEEP
so bonding can be a boolean
"does this operator have enough of a bond to participate or not".

=== Privileged customer applications

Unlike in the Random Beacon,
where the customer does not matter for group selection,
ECDSA keeps must be able to have privileged customer applications
that may seize the bonded tokens at their discretion.

This means that it is not enough to ensure
that the EDCSA keep factory is authorized to slash operators.
Instead, each privileged customer must be individually authorized
to seize the selected operators' bonds.
Thus, eligibility must be determined on a per-customer basis.

To make matters more complex,
customers should not be able to interfere with each other.
If adding a new privileged customer
can increase the cost of on-chain actions for the old customers,
a variety of DOS attacks becomes possible.

=== Prohibiting visible duplicate members?

In the Random Beacon,
a single operator with a staker weight greater than 1
can have multiple members in a single signing group.
This ensures better proportionality,
reduces incentives to blitzpants
(and thus obfuscate the true level of centralization in stakes),
and is harmless when groups have tens of members
as a single operator is very unlikely to control a disproportionate fraction.

With only 3 members,
the probability of a single operator controlling the entire group
is vastly higher.
An operator with 5% of the total stake
is astronomically unlikely to have a controlling majority
of 33 in 64 members,
but would have 1 in 8,000 chance of controlling 3 in 3 members.

If such _visible duplicates_
(members controlled by the same operator address)
are permitted,
it may cause unhappiness among customers
who aren't accustomed to applying the security mindset.
Because such individuals make up the vast majority
of posts on Twitter and Hacker News,
we can't tell them to just git gud{blank}footnote:willnotjust[
As per the theorem of _People Will Not Just_;
there is not a single instance in recorded history
of people having just,
and they certainly aren't going to start now
]
and need to consider the optics of our member selection scheme.

In the actual reality
anyone planning malicious action
would most likely blitzpants
the hell out of their stakes anyway
to conceal their capabilities for nefarious coordination.
Thus the impact is only really limited
to operators starting out as honest.
And because honest whales are a wee bit less likely to be selected,
naughty blitzpantsers will be ever so slightly overrepresented
in the ECDSA keeps.

However, a legit benefit of banning visible dupes
is that a single operator's client node getting hacked
can't result in the hacker immediately running away with the BTC deposit,
no matter how lucky the unlucky operator previously was.

Prohibiting visible duplicates
harms the proportionality of the selection process
as large stakers get marginally less return from their capital,
and thus creates a slight incentive to blitzpants,
but the impact is dramatically lesser than in the Random Beacon.
Permitting visible duplicates
may also lead to implementation complications
because a single client node may need to play multiple roles simultaneously.

To ensure we don't screw up right in the beginning of the process,
this draft isn't going to commit either way on this question.
Both options will be explored.

== Common features

Some solutions to various parts of the whole question
don't vary between the candidate schemes.

=== Independent bonding contracts

We're likely to want to use currency bonding in future keep protocols.
Thus, instead of implementing bonding separately in each protocol
it is preferable to have one general-purpose bonding contract
for each bonding scheme
(a specific currency and ruleset).

Just like the staking contract,
these bonding contracts make the bond currency available
to contracts authorized by the operator's authorizer.
Unlike in the staking contract,
the fully backed bonds can either be directly transferred to keeps,
or assigned to them in the bonding contract.

=== New authorizations

When a keep/factory wants to use an operator's bond,
it needs to be authorized.
This authorization must be a part of an operator's eligibility for selection.

In the case of privileged customer applications,
the privileged application itself must be authorized.
If the privileged applications can only seize bonds,
the staking contract doesn't need to be changed to accommodate them.

== Adapted ticket scheme

- Authorization checks are simple to perform
- Relatively small gas cost overhead,
small _n_ requires less optimization than in the Beacon
- Existing implementation can mostly be reused
- Ticket submission takes time,
and small _n_ makes it slower (!!)

The Random Beacon currently uses a scheme
where each operator has a number of virtual stakers
equal to their staker weight
(total stake divided by the minimum stake to participate),
and each virtual staker gets assigned a pseudorandom _ticket_ value
in each group selection,
with a smaller ticket value being more valuable.
The operators then submit promising tickets on-chain,
and finally the lowest _n_ tickets are selected to form the group.
Eligibility for the group selection is checked on ticket submission,
and operators are given a reasonable amount of time to submit their tickets
so they can monitor the on-chain situation
to determine their likelihood of getting selected
and thus avoid submitting unnecessary tickets.

With slight adaptation
a ticket-based scheme would be suitable
for the unique requirements of ECDSA keeps.

=== Pros

A ticket-based scheme is a decent fit for ECDSA keeps
as it provides simple solutions to many of the requirements.
Operators' bond and authorization status can be queried
when they submit their tickets
along with the rest of the eligibility check.

The cost of ticket-based selection requiring _O(n)_ transactions
is kept in check by _n = 3_,
and tracking the _n_ best tickets during submission
is likewise rather simple and inexpensive.

The Random Beacon already has a working implementation of a ticket scheme
so ECDSA member selection could ship without much extra work.

=== Cons

The downsides of ticket-based selection
are mostly the same as in the Beacon;
submitting tickets costs gas, takes time,
and is vulnerable to censorship.
The main differences to the Beacon are
that the gas costs are somewhat less of an issue,
and that the time taken is more significant.

In the Random Beacon signing groups are created ahead of time
and only chosen to perform work
when they have finished their key generation.
ECDSA keeps are created in response to demand,
so having to wait for ticket submission is more problematic.

Even worse, when only 3 members are selected
the ticket submission itself has to be slower.
With a large _n_ the variability in the values of the _n_ best tickets
is substantially lower,
and the relative impact of a redundant ticket submission is lesser.
When only the 3 best tickets matter,
both the probability and the cost of redundant submission are higher.
To compensate for this,
the ticket submission period can't be dramatically shorter,
and may even need to be longer than in the Beacon.

An actor capable of censoring on-chain transactions
may be able to manipulate the outcome.
Attacks can be targeted by calculating other operators' ticket values.
Ticket schemes can be hardened
against targeted attacks that rely on pre-calculation
at the cost of higher gas expenses
by using a signature of the selection seed as the ticket value.
Miner censorship attacks aren't affected by this mitigation.

=== Implementation

As in the Beacon,
operators calculate and submit tickets.
Unlike the Beacon,
we only need to store the 3 best tickets
and can just read+compare each submitted ticket to all of them.

If operator _P_ submits a ticket
while the best 3 tickets already have a ticket from _P_,
only the better of the two tickets is kept
and the other one is discarded.

Ticket-based selection has a practical cost floor of
_21,000 + 2,400 + 5,000 = 28,400_ gas per ticket
for _n = 3_
(transaction base fee + 3 read operations + 1 write).
The total cost floor is _85,200_ gas.

== Lazy non-interactive sortition

- Each privileged customer has its own sortition pool
and eligibility is checked when an operator is selected,
rejecting and removing ineligible operators from the pool
- Non-interactive sortition requires significant optimization
even with logarithmic data structures,
but once optimized is easily scalable for larger _n_
- Requires significant implementation work
- Provides instant results and is less affected by censorship,
although malicious miners can still censor DKG result submissions

A logarithmic data structure could be used
to store the pool of eligible operators,
weighted by their stakes.
Sortition from the pool would be performed
without waiting for input from operators.

=== Lazy eligibility evaluation

Each pair of (keep factory, privileged customer)
would require its own sortition pool.
An operator enters a sortition pool by opting in.
The pool checks their eligible tokens
(including operator status and authorization to slash stakes),
and available bonding currency
(including authorization to seize bonds).
The operator pays the transaction fees for the pool update.

Keeping these pools up to date cannot be done eagerly
as proliferation of privileged customers
could be used to perform DOS attacks
by increasing the cost of such updates.
When a sortition pool prospectively selects an operator,
the selected operator's eligibility status and weight are checked
and, if necessary, updated in the sortition pool.
If the changes would be detrimental to the operator,
the operator selection is performed again with the updated input
to ensure correctness.

The number of operator selections required to get _n_ valid members
averages _n / (1 - e)_
where _e_ equals the fraction of weight in the pool
belonging to operators whose information is detrimentally out of date.
If 50% of the pool weight is outdated,
the average number of selections is 6,
roughly 2% of ECDSA keeps would require 12 or more operator selections,
and more than 20 selections would be extremely rare.
Sortition pools that are used more often would be less outdated.

=== Optimizing data structures

Even though logarithmic data structures are well-known,
the particular characteristics of Ethereum smart contracts
require specialized optimization
to make non-interactive sortition viable.

To enable weighted sortition,
each sortition pool would have a weighted tree
where each leaf stores an operator
and is labeled with the operator's sortition weight,
and each branch is labeled with the sum of the weights of its children.
To select an operator from the pool,
a pseudorandom number in _[0, W)_
(where _W_ is the total sortition weight of the tree)
is acquired and used to index into the tree.

==== Background

A single storage field in the EVM consists of 256 bits/32 bytes.
Data structures on the EVM are naturally sparse.
An implicit heap can eliminate the need for pointers
so the full capacity of each storage field can be used for content data.

KEEP tokens have 18 decimals and the total supply is 1,000,000,000 KEEP.
A precise token amount would require roughly 96 bits/12 bytes to store.
However, the minimum stake required to participate
is expected to be in the region of 1/100,000 of the total KEEP supply.

==== Unoptimized binary trees

Only a binary tree is possible with precise token amounts.
Even with a conservative estimate of minimum stake
at 62,000 KEEP (more than 1/16,384 of all KEEP)
the number of possible virtual stakers is roughly 2^14^.
The number of KEEP owned by each account
is expected to follow a power law distribution,
and the number of accounts holding at least 1/2^14^ of the total
is expected to be approximately 2^11^ to 2^14^.
Again taking the optimal case gives a height of 11 for a binary tree.
Updating a single node in the tree,
along with its path from the root,
would require up to 14 write operations at a cost of 55,000 ~ 70,000 gas.
Accessing a node in the tree
would similarly require up to 14 read operations at 8,800 ~ 11,200 gas.

==== Optimized higher arity trees

Instead of using the exact token amount,
each operator's sortition weight should use their staker weight
as in the Random Beacon group selection.
Because a staker weight exceeding 65,535
would represent catastrophic centralization in the network,
16 bits is sufficient for all practical purposes
even if the minimum stake is somewhat less than 10,000 KEEP.

A storage field can hold 16 values of 16 bits.
This gives a theoretical ceiling of 1,048,560 possible virtual stakers
for a node containing the weights of its 16 children. 
With a pessimal distribution of child nodes' weights,
524,288 virtual stakers can be accommodated.
The maximum permitted staker weight of 65,535
represents approximately 13% of all tokens in the pessimal distribution.
Assuming each staker divides their staked tokens
equally between two different operators
as recommended for smooth upgrades,
a single actor following best practices would need to hold 25% of all KEEP
to be affected by the staker weight cap of 16 bits.
Such an actor would already be a threat to the Keep network
and we have no need to accommodate them,
so all child nodes can be capped to 16 bits without issues.

===== Version A: up to 524,288 virtual stakers

If the tree is instead packed optimally using `uint16`,
we get the following numbers of nodes per level:

. 1
. 16
. 256
. 4,096
. 65,536
. 1,048,576

A 16-ary tree of height 6 is sufficient to hold all possible operators
within the limits of the pessimal distribution of 16-bit weights.
Updating a path in this tree would only use up to 30,000 gas,
and accessing a node would cost at most 4,800 gas.

The minimum stake must be at least 1,910 KEEP.

A branch node consists of `{uint16[16] children}`
where each field is the weight of its corresponding child.
A weight of `0` means the child node is empty.

A leaf node consists of `{uint16 weight; address operator}`.

===== Version B: up to 131,072 virtual stakers

If the minimum stake to participate
is at least 7,630 KEEP (more than 1/131,072 of the total supply)
the height of the tree can be reduced to 5
by using `uint8` for the children of level 4 branches,
with the width of level 5 being 131,072.
Operators with more than 255 times the minimum stake
would be held in leaves of level 4 or less.
Because there can be at most 512 such operators,
level 4 is wide enough to hold them.

A branch on levels 1 to 3 consists of `{uint16[16] children}`,
while a branch on level 4 consists of `{uint8[32] children}`.

A leaf consists of `{0x0000; uint16 weight; address operator}`.

To make the magic number `0x0000` useful
at distinguishing leaves from branches,
it is necessary to enforce the invariant
that the first child of a branch may not be empty.
If the first child of a branch is deleted,
another child must be moved into the first position.

===== Version C: up to 65,536 virtual stakers

If the minimum stake is at least 15,260 KEEP
(at most 65,536 virtual stakers),
a tree of height 5 can be used without the special cases of _version B_.
Branches and leaves are as in _version A_.

==== Metadata

===== Empty node locations

To help insert operators into the tree,
there should be lists for levels 2 to 5 (_version A_)
or 2 to 4 (_version B & C_)
containing the branches with empty children on that level.

===== Operators' tree positions?

In addition to the weighted tree,
a sortition pool may have a `mapping(address operator => uint) treePosition`
to help locate operators in the tree.
However, because of the lazy updates this is not strictly necessary.

==== Operations

===== Insertion

Inserting a new operator into the tree
is performed in the leftmost empty node of the appropriate level
whose level 2 ancestor's weight would not overflow
from the addition of the new operator.
The weights of the node's ancestors are updated,
and if the parent node's children are now full
it is removed from the list of branches with empty children.

===== Selection

The total weight of the tree _W_ can either be stored separately
or calculated by summing the weights of the root's children.

An entry _V_ is requested from the Random Beacon,
and an index _i_ in the range _[0, W)_ is derived from _V_
using a standard algorithm for secure integers in an arbitrary interval.
Using `i = V % W` is not safe and will lead to biasing the results,
summoning demons from hell,
and embarrassing the entire company on Twitter and Hacker News.

At a branch node,
if _i_ is less than the first child's weight _w~1~_
the first child is entered;
otherwise _i -= w~1~_
and is compared to the second child's weight _w~2~_
and so on until a leaf is reached.

The address _P_ in the leaf is the _prospective selected operator_,
with weight _w~P~_.

The staking contract is queried to get the eligible stake of _P_,
and the up-to-date weight _W'~P~_ is calculated.

If _W'~P~ = W~P~_, the weight is up to date and we proceed.

If _W'~P~ > W~P~_, something funny is going on
because the current spec doesn't include
increasing the staked tokens of an operator after the operator has been created
but if this is the future and we're doing that now
we proceed but also queue the weight for updating.

If _W'~P~ < W~P~_, we queue the weight for updating
and because the update would be in a direction detrimental to the operator,
we also queue a new operator selection with the same _i_
once we're done with the update.
If _W'~P~ == 0_, the operator _P_ is queued for deletion
and we don't bother querying the bond.

Then we query the bonding contract to get the available bond _B~P~_
and compare it to the minimum bond _B_:

If _B~P~ < B_, we queue the operator for deletion
and queue a new selection with _i_
after _P_ is deleted from the sortition pool.

If _B~P~ >= B_ and we previously queued a new selection,
we perform the queued update and selection.

If _B =< B~P~ < 2B_ and we previously proceeded,
the operator _P_ is selected but they don't have enough bond to stay eligible
so _P_ is deleted from the sortition pool.

If _B~P~ >= 2B_ and we previously proceeded,
the operator _P_ is selected and they have enough bond to stay in the pool.
We then perform queued updates, if any.
